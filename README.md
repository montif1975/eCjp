# eCjp
## Easy C JSON Parser

This is a simple library written entirely in C that implements a parser for a UTF-8 character string containing a JSON structure.  
There are many other libraries written in C already available; I decided to write this one to use it in my projects without having to worry about the usage conditions of other libraries.

The main features of the library are:
- it does not depend on other libraries, only on the standard libc;
- it does not use recursion (if needed, it must be implemented by the calling program);
- it can be compiled for MCU or CPU depending on the available resources (memory and speed);
- it does not modify the original JSON;
- it parses a JSON structure and reports the position of the first syntax error;
- it tolerates duplicate keys;
- it is released under the BSD 3-Clause license;
- it consists of a single source file and two include files (plus the `config.h` generated by *configure*).

The library implements **only JSON parsing**, not JSON creation or modification.

There are two implementations in the source code:
- one implementation tokenizes the first level of a JSON structure, creating a list of tokens;
- an alternative implementation creates a list containing the position and length of all keys within the JSON.

In both cases, the memory allocated for the lists must be freed by the calling program after use: the library provides specific functions for this purpose.

---

## Contents

1. [Prerequisite](#prerequisite)
2. [Project tree](#project-tree)
3. [Build on Linux](#build-on-linux)
4. [API](#api)
5. [Examples](#examples)
6. [Tests](#tests)
7. [Remarks](#remarks)

---

## Prerequisite

To build the library on Linux, the following tools are required:
- **gcc** (tested with gcc 14.2.0)
- **make** (tested with GNU Make 4.4.1)
- **autoconf** (tested with GNU Autoconf 2.72)

---

## Project tree

Once the project has been downloaded, the main directories are:

```
build
include
src
scripts
tests
```

| Directory | Description |
|----------|-------------|
| build | build directory |
| include | include directory |
| src | source directory: contains the library source and all test programs |
| scripts | contains the scripts used to run the tests |
| tests | contains JSON files (valid and invalid) used for testing |

The library files are only the following:  
*ecjp.c*, *ecjp.h*, *ecjp_limit.h*, plus the *config.h* include file generated by the *configure* tool.

---

## Build on Linux

After downloading the source code, run the following commands:

```sh
$ autoreconf -i
$ cd build
```

The available build options can be displayed by running:

```sh
$ ../configure -h
```

The library-specific options are:

```sh
--enable-debug          Enable DEBUG macro
--enable-debug-verbose  Enable DEBUG_VERBOSE macro
--enable-token-list     Enable ECJP_TOKEN_LIST macro
--enable-run-on-pc      Enable ECJP_RUN_ON_PC macro
--enable-run-on-mcu     Enable ECJP_RUN_ON_MCU macro
```

The effect of each option is described in the following table:

| OPTION | DESCRIPTION |
|--------|-------------|
| --enable-debug | enable DEBUG print on stdout |
| --enable-debug-verbose | enable VERBOSE print on stdout |
| --enable-token-list | compile token-list version of the library |
| --enable-run-on-pc | set the limits in the code to run on CPU |
| --enable-run-on-mcu | set the limits in the code to run on MCU |

When the *run-on-mcu* option is enabled, the library uses very little memory but enforces very low limits on the size of the structures it can parse and on the number of levels in the JSON structure.  
Moreover, with this option enabled, the *debug* and *debug-verbose* options have no effect because **when compiled for MCU all outputs are suppressed**.

Example of compilation for PC using the token-based implementation:

```sh
$ ../configure --enable-debug --enable-token-list --enable-run-on-pc
$ make
```

The compilation produces:
- in the `build/src/.libs` directory the libraries **libecjp.so.0.0.0** and **libecjp.a**;
- in the same directory the following executables:
  - `example_ecjp_X` = example program demonstrating library usage
  - `test_lib_X` = example programs to test specific library functions

Some example and test programs work depending on the build configuration: if the *token-list* option is not supported, the program exits with an error message.

## API

The library provides a set of APIs that together allow parsing JSON structures of relatively high complexity.  

### ecjp_dummy()  

`ecjp_return_code_t ecjp_dummy(void)`  

A simple dummy function to test library linkage.

No Parameters.

Returns:  
- ECJP_NO_ERROR on success.

Example:
```c
  ecjp_return_code_t ret = 0; 
  
  ret = ecjp_dummy();
  if (ret != ECJP_NO_ERROR) {
      printf("ecjp_dummy() failed with error code: %d\n", ret);
      printf("Unable to load library?\n");
  }
  else {
      printf("ecjp_dummy() succeeded.\n");
  }
```

### ecjp_get_version()  

`ecjp_return_code_t ecjp_get_version(int *major, int *minor, int *patch)`  

This function retrieves the version of the eCjp library. It stores the major, minor and patch in the three pointer passed as arguments.

Parameters:  
- major: Pointer to an integer to store the major version number.  
- minor: Pointer to an integer to store the minor version number.  
- patch: Pointer to an integer to store the patch version number.  

Returns:  
- ECJP_NO_ERROR on success.  

Example:  
```c
  int major, minor, patch;
  ecjp_return_code_t ret;
  
  ret = 0;
  major = minor = patch = 0;

  ret = ecjp_get_version(&major, &minor, &patch);
  if (ret != ECJP_NO_ERROR) {
      printf("ecjp_get_version() failed with error code: %d\n", ret);
  }
  else {
      printf("ecjp_get_version() succeeded. Version: %d.%d.%d\n", major, minor, patch);
  }
```

### ecjp_get_version_string()  

`ecjp_return_code_t ecjp_get_version_string(char *version_string, int max_length)`  

This function retrieves the version of the eCjp library as a string.  

Parameters:  
- version_string: Pointer to a character array to store the version string.  
- max_length: Maximum length of the version string buffer.  

Returns:  
- ECJP_NO_ERROR on success.
- ECJP_NULL_POINTER if version_string is NULL or max_length is 0.

Example:  
```c
  char version_string[16];
  ecjp_return_code_t ret;
  
  ret = 0;
  memset(version_string, 0, sizeof(version_string));

  ret = ecjp_get_version_string(version_string, sizeof(version_string));
  if (ret != ECJP_NO_ERROR) {
      printf("ecjp_get_version_string() failed with error code: %d\n", ret);
  }
  else {
      printf("ecjp_get_version_string() succeeded. Version string: %s\n", version_string);
  }
```

### ecjp_show_error()  

`ecjp_return_code_t ecjp_show_error(const char *input, int err_pos)`  

This function displays the input string with an indicator pointing to the error position.  
The function formats the output in ECJP_MAX_PRINT_COLUMNS colums (defined in *ecjp_limit.h*). 

Parameters:  
- input: The JSON-like input string.  
- err_pos: The position of the error in the input string.  

Returns:  
- ECJP_NO_ERROR on success.

Example:
```c
ecjp_return_code_t ret = ECJP_NO_ERROR;
ecjp_check_result_t results;
char *ptr; // pointer to the JSON-like input string

ret = ecjp_check_syntax_2(ptr,&results);
if (ret != ECJP_NO_ERROR) {
    printf("ecjp_check_syntax_2() on JSON file: FAILED with error code: %d\n", ret);
    if (results.err_pos >= 0) {
        printf("ecjp_check_syntax_2(): Error position: %d\n", results.err_pos);
        ecjp_show_error(ptr, results.err_pos);
    }
}
```  

**At the moment, this following part describes the functions of the implementation enabled by the *token-list* option, which tokenizes the JSON structure.**

### ecjp_check_syntax_2()

`ecjp_return_code_t ecjp_check_syntax_2(const char *input, ecjp_check_result_t *res)`

This function call ecjp_check_and_load_2() without pointer to store the items to perform only syntax checking.  

Parameters:
- input: The JSON-like input string to be checked.
- res: Pointer to a structure to store the result of the check, including any error position.  

Returns:
- ECJP_NO_ERROR if the input string is a JSON valid structure.
- ECJP_NULL_POINTER if any input pointer is NULL.
- ECJP_EMPTY_STRING if the input string is empty.
- ECJP_SYNTAX_ERROR if there is a syntax error in the input string.  

The **ecjp_check_syntax_2()** function checks the syntactical correctness of a JSON structure passed as an argument.
The function outputs the position of the first error in the JSON structure in the *res->err_pos* parameter. This value can be passed to the *ecjp_show_error()* function to print the error in the context of the parsed JSON string. For example: 
``` sh
Testing input file: ../../tests/invalid_15_missing_quote_in_key.json

Testing JSON file (../../tests/invalid_15_missing_quote_in_key.json) of size 35 bytes:
ecjp_check_and_load_2 - 938: Expected colon after key, received: V
ecjp_check_syntax_2() on JSON file: FAILED with error code: 3
ecjp_check_syntax_2(): Error position: 27
ecjp_show_error - 350: Error at position 27 (row 1, column 28):
{ "KEY1": "VAL1", "KEY_2: "VAL2" } 
---------------------------^
```  
The structure pointed by *res* contains the following fields:
```c
typedef struct ecjp_check_result {
    int                 err_pos;
    ECJP_TYPE_POS_KEY   num_keys;
    ecjp_struct_type_t  struct_type;
    int                 memory_used;
} ecjp_check_result_t;
```
and the function returns the type of the parsed JSON structure in the field *struct_type*: ECJP_ST_OBJ for an object, ECJP_ST_ARRAY for an array. 

Example:  
```c
ecjp_return_code_t ret = ECJP_NO_ERROR;
ecjp_check_result_t results;
char *ptr; // pointer to the JSON-like input string

ret = ecjp_check_syntax_2(ptr,&results);
if (ret != ECJP_NO_ERROR) {
    printf("ecjp_check_syntax_2() on JSON file: FAILED with error code: %d\n", ret);
    if (results.err_pos >= 0) {
        printf("ecjp_check_syntax_2(): Error position: %d\n", results.err_pos);
        ecjp_show_error(ptr, results.err_pos);
    }
} else {
  printf("ecjp_check_syntax_2() on JSON file: SUCCEEDED\n");
}
```

### ecjp_load_2()  

`ecjp_return_code_t ecjp_load_2(const char *input, ecjp_item_elem_t **item_list, ecjp_check_result_t *res)`

This function call ecjp_check_and_load_2() with pointer to store the items. Perform syntax checking and store all items found in the input string at the first level of the structure.  

Parameters:
- input: The JSON-like input string to be checked and loaded.
- item_list: Pointer to a list of item elements loaded with the items found in the input string.
- res: Pointer to a structure to store the result of the check, including any error position.  

Returns:
- ECJP_NO_ERROR if the input string is valid.
- ECJP_NULL_POINTER if any input pointer is NULL.
- ECJP_EMPTY_STRING if the input string is empty.
- ECJP_SYNTAX_ERROR if there is a syntax error in the input string.

The function allocates as many *ecjp_item_elem_t* as there are elements at the first level of the JSON structure.
If the JSON is an object, the items are the key-value pairs; if the JSON is an array, the items are the array elements, and each element's type is specified.
**Each item, whether a key-value pair or an array element, is saved as a string**.
When the calling function no longer needs it, it must free the allocated memory by calling the *ecjp_free_item_list()* function.
In the structure pointed to by *res*, there is the *memory_used* field, which contains the total memory allocated in bytes in the *item_list*.

Example:  
```c
ecjp_return_code_t ret = ECJP_NO_ERROR;
ecjp_check_result_t results;
char *ptr; // pointer to the JSON-like input string
ecjp_item_elem_t *item_list = NULL;

ret = ecjp_load_2(ptr,&item_list,&results);
if (ret != ECJP_NO_ERROR) {
    printf("ecjp_load_2() on JSON file: FAILED with error code: %d\n", ret);
    ecjp_free_item_list(&item_list);
} else {
    printf("ecjp_load_2() on JSON file: SUCCEEDED\n");
}
```

### ecjp_check_and_load_2()  

`ecjp_return_code_t ecjp_check_and_load_2(const char *input, ecjp_item_elem_t **item_list, ecjp_check_result_t *res)`  

This function checks the syntax of a JSON-like input string and loads item tokens into a linked list if the syntax is valid.  

Parameters:
- input: The JSON-like input string to be checked and loaded.
- item_list: Pointer to a list of item elements loaded with the item tokens found in the input string.
- res: Pointer to a structure to store the result of the check, including any error position.  

Returns:
- ECJP_NO_ERROR if the input string is valid.
- ECJP_NULL_POINTER if any input pointer is NULL.
- ECJP_EMPTY_STRING if the input string is empty.
- ECJP_SYNTAX_ERROR if there is a syntax error in the input string.

If the JSON structure passed in *input* has duplicate keys (although this is not a good practice), the *ecjp_load_2()* or *ecjp_check_and_load_2()* function loads them all into different items anyway.  
The user code can use *ecjp_load_2()*, no need to use this function directly but it's possible as described in the example.

Example:
```c
ecjp_return_code_t ret = ECJP_NO_ERROR;
ecjp_check_result_t results;
char *ptr; // pointer to the JSON-like input string
ecjp_item_elem_t *item_list = NULL;

ret = ecjp_check_and_load_2(ptr,&item_list,&results);
if (ret != ECJP_NO_ERROR) {
    printf("ecjp_check_and_load_2() on JSON file: FAILED with error code: %d\n", ret);
    ecjp_free_item_list(&item_list);
} else {
    printf("ecjp_check_and_load_2() on JSON file: SUCCEEDED\n");
}
```

### ecjp_free_item_list()  

`ecjp_return_code_t ecjp_free_item_list(ecjp_item_elem_t **item_list)`  

This function free the memory allocated for a list of item elements.  

Parameters:
- item_list: Pointer to the list of item elements to be freed.  

Returns:
- ECJP_NO_ERROR if the list is freed successfully.

Example:  
```c
ecjp_return_code_t ret = ECJP_NO_ERROR;
ecjp_check_result_t results;
char *ptr; // pointer to the JSON-like input string
ecjp_item_elem_t *item_list = NULL;

ret = ecjp_load_2(ptr,&item_list,&results);
if (ret != ECJP_NO_ERROR) {
    printf("ecjp_load_2() on JSON file: FAILED with error code: %d\n", ret);
} else {
    printf("ecjp_load_2() on JSON file: SUCCEEDED\n");

    // ...ELABORATION...
}
ecjp_free_item_list(&item_list);  
```

### ecjp_read_element()  

`ecjp_return_code_t ecjp_read_element(ecjp_item_elem_t *item_list, int index, ecjp_outdata_t *out)`  

This function reads an element from the item list by its index and copies its value to the output structure.  

Parameters:
- item_list: Pointer to the head of the ecjp_item_elem_t linked list.
- index: The index of the element to read.
- out: Pointer to an ecjp_outdata_t structure where the output will be stored.  

Returns:
- ECJP_NO_ERROR on success
- ECJP_NULL_POINTER if item_list or out is NULL
- ECJP_INDEX_OUT_OF_BOUNDS if the index is out of bounds (no more items in the list)

The structure pointed by *out* contains the following fields:   
```c
typedef struct ecjp_outdata {
    ecjp_return_code_t  error_code;
    ECJP_TYPE_POS_KEY   last_pos;
    ECJP_TYPE_LEN_KEY   length;
    ecjp_value_type_t   type;
    void                *value;
    unsigned int        value_size;
} ecjp_outdata_t;
```  

The *value* field is currently intentionally a pointer to *void*, but the function copies the string containing the item.
If the original JSON structure was an object, a key-value pair will be stored inside value; if it was an array, the element of the index array *index* will be stored.  

Example:
```c
  ecjp_outdata_t out;
  char key[ECJP_MAX_KEY_LEN];
  char value[ECJP_MAX_KEY_VALUE_LEN];
  int index = 0;

  memset(&out, 0, sizeof(ecjp_outdata_t));
  out.value = malloc(ECJP_MAX_ITEM_LEN);
  // scan all the item list
  do {
      out.value_size = ECJP_MAX_ITEM_LEN;
      memset(out.value, 0, ECJP_MAX_ITEM_LEN);
      if(ecjp_read_element(item_list, index, &out) == ECJP_NO_ERROR) {
          if (out.type == ECJP_TYPE_KEY_VALUE_PAIR) {
              // parse key-value pair
              memset(key, 0, sizeof(key));
              memset(value, 0, sizeof(value));
              sscanf((char *)out.value, "%[^:]:%[^\n]", key, value);
              printf("  Key = '%s', Value = '%s'\n", key, value);
          }
      }
      else {
          break;
      }
      index++;
  } while (1);

  // random access example
  ecjp_fprint("Example of random access:\n");

  out.value_size = ECJP_MAX_ITEM_LEN;
  memset(out.value, 0, ECJP_MAX_ITEM_LEN);
  // read element of index=0
  ecjp_read_element(item_list, 0, &out);

  // read element of index=1
  out.value_size = ECJP_MAX_ITEM_LEN;
  memset(out.value, 0, ECJP_MAX_ITEM_LEN);
  ecjp_read_element(item_list, 1, &out);  
```  

### ecjp_split_key_and_value()  

`ecjp_return_code_t ecjp_split_key_and_value(ecjp_item_elem_t *item_list, char *key, char *value, ecjp_bool_t leave_quotes)`  

This function splits a key-value pair item into separate key and value strings.  
This feature is only useful if you are compiling for MCU and you cannot use the function `sscanf((char *)out.value, "%[^:]:%[^\n]", key, value)`.

Parameters:
- item_list: Pointer to the ecjp_item_elem_t containing the key-value pair.
- key: Pointer to a char array where the extracted key will be stored.
- value: Pointer to a char array where the extracted value will be stored.
- leave_quotes: Boolean flag indicating whether to retain quotes around the key.  

Returns:
- ECJP_NO_ERROR on success
- ECJP_NULL_POINTER if any input pointer is NULL
- ECJP_SYNTAX_ERROR if the item is not a key-value pair
- ECJP_NO_SPACE_IN_BUFFER_VALUE if the key or value exceeds maximum length of the buffers  

This function allows you to separate a key-value pair into two separate strings.  
If the item does not contain a key-value pair, an error is returned.  

Example:  
```c
  ecjp_item_elem_t *current_item;
  char extracted_key[ECJP_MAX_KEY_LEN];
  char extracted_value[ECJP_MAX_KEY_VALUE_LEN];
  ecjp_return_code_t split_res = ECJP_NO_ERROR;

  if (current_item->item.type == ECJP_TYPE_KEY_VALUE_PAIR) {
      split_res = ecjp_split_key_and_value(current_item, extracted_key, extracted_value, ECJP_BOOL_FALSE);
      if (split_res != ECJP_NO_ERROR) {
          printf("Fail to split key and value pair (res = %d)\n", split_res);
          return split_res;
      }
      printf("extracted_key = %s, extracted_value = %s\n", extracted_key, extracted_value);
  }  
```

### ecjp_read_key_2()  

`ecjp_return_code_t ecjp_read_key_2(ecjp_item_elem_t *item_list, const char *key, unsigned int index, ecjp_outdata_t *out)`  

This function reads the value associated with a specified key from the item list, starting from a given index.  

Parameters:
- item_list: Pointer to the head of the ecjp_item_elem_t linked list.
- key: The key to search for.
- index: The starting index for the search.
- out: Pointer to an ecjp_outdata_t structure where the output will be stored.  

Returns:
- ECJP_NO_ERROR on success
- ECJP_NULL_POINTER if item_list, key, or out is NULL
- ECJP_INDEX_NOT_FOUND if the key is not found in the list

This function searches for the key *key* within the list of items, starting at the index specified by *index* and checking only for key-value items.  
The function returns the position in the list where it found the key in the structure pointed to by *out*, in the *last_pos* field. This allows the function to be called again with *index=last_pos + 1* to continue scanning the list for duplicate keys.  
When the function returns ECJP_INDEX_NOT_FOUND, it has completed the list without finding the key (or other keys).  

Example:
```c
  char search_key[] = "KEY_1";
  ecjp_outdata_t out;
  int index = 0;

  memset(&out, 0, sizeof(ecjp_outdata_t));
  out.value = malloc(ECJP_MAX_ITEM_LEN);
  do {
      out.value_size = ECJP_MAX_ITEM_LEN;
      memset(out.value, 0, ECJP_MAX_ITEM_LEN);
      out.length = 0;
      out.last_pos = 0;

      if(ecjp_read_key_2(item_list, search_key, index, &out) == ECJP_NO_ERROR) {
          printf("  Key = '%s', Value = '%s'\n", search_key, (char *)out.value);
      }
      else {
          break;
      }
      index = out.last_pos + 1;
  } while (1);  
```  

## Examples  

The folder *src* contains a lot of test and example programs that are described in the table.  

|       PROGRAM         | USED TO TEST                                  | TOKEN-LIST IMPLEMENTATION | KEY-POSITION IMPLEMENTATION |
|-----------------------|-----------------------------------------------|---------------------------|-----------------------------|
|test_lib_load (*)      | ecjp_dummy()                                  |             X             |               X             |
|test_lib_version (*)   | ecjp_get_version(), ecjp_get_version_string() |             X             |               X             |
|test_lib_check_syntax  | ecjp_check_syntax_2(),ecjp_show_error()       |             X             |               -             |
|test_lib_check_and_load| ecjp_check_and_load(), ecjp_free_key_list()   |             -             |               X             |
|test_lib_read_array    | ecjp_check_and_load(), read_single_array_element()|         -             |               X             |
|test_lib_get_key       | ecjp_load_2(), ecjp_read_key_2(), ecjp_free_item_list()|    X             |               -             |
|example_ecjp_1         | complete parsing                              |             -             |               X             |
|example_ecjp_2         | complete parsing                              |             -             |               X             |
|example_ecjp_3         | complete parsing                              |             X             |               -             |

(*) no input required  
To execute the program that require argument, I prepared a lot of file with different JSON inside; they are in *tests* folder.  
Some of them are *invalid* JSON to test the check syntax algorithm: the file name explain the type of JSON that it contains. 

## Tests  

The two batch script inside the *scripts* folder can be used to perform test in very quick way.  
To use the *example_ecjp_3* program it's enough to launch the script *run_test.sh*:  
```sh
$ cd scripts
$ ./run_test.sh
```
The script launches the program *example_ecjp_3* with each of the files in the *tests* folder as an argument and print the result: PASS or FAIL.  
To change the program to lauch, change the script *run_test.sh*.  

## Remarks  

At the moment there are these TODOS:
- the compilation process produce library and executables with debug symbols, no stripped. I need to add RELEASE compilation.
- the test *valid_11_deep_nesting.json* pass only with compilation for CPU due the limit of MCU parsing.
- the test *valid_03_unicode.json* pass but the parsing fail the value of key "escaped" missing the characters "\n" e "\t" inside the string value.
- the test *valid_08_escaped_unicode.json* pass but the parsing of the value of the keys "escapedQuotes" and "slashes" are not correct. Need to be fixed.  










